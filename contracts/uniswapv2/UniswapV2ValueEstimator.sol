pragma solidity =0.6.12;

import './interfaces/IUniswapV2Factory.sol';
import './interfaces/IUniswapV2Pair.sol';
import './libraries/SafeMath.sol';

// Use swap contracts to estimate the total value of the tokens and amounts
// specified, relative to some reference token. Note that this does NOT represent
// the amount that could be generated by token sales; for instance, no attempt
// is made to carefully chart a swap path for maximum return, and the amounts
// in question may already be providing liquidity to one of the swaps! Take this
// as a rough guide of how much "value" is present in the collection, not how
// much one could gain by a batch sale.
contract UniswapV2ValueEstimator {
  using SafeMathUniswap for uint;

  address public immutable factory;
  address public immutable WETH;

  constructor(address _factory, address _WETH) public {
    factory = _factory;
    WETH = _WETH;
  }

  function estimateValueETH(address[] calldata _tokens, uint256[] calldata _values) public view returns (uint256 _value) {
    _value = estimateValue(_tokens, _values, WETH);
  }

  function estimateValue(address[] calldata _tokens, uint256[] calldata _values, address _referenceToken) public view returns (uint256 _value) {
    for (uint i = 0; i < _tokens.length; i++) {
      address token = _tokens[i];
      uint256 value = _values[i];
      if (token == _referenceToken) {
        _value = _value.add(value); // easy
      } else {
        (uint reserveIn, uint reserveOut) = getReserves(token, _referenceToken);
        _value = _value.add(getAmountOut(value, reserveIn, reserveOut));
      }
    }
  }

  // From the Uniswap Library and Router, rewritten to avoid throwing errors
  // unless absolutely necessary (such as integer overflow).
  // If such an error would occur, such as invalid liquidity, provides
  // value 0 instead.
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
  }

  function getReserves(address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
    address pairAddress = IUniswapV2Factory(factory).getPair(tokenA, tokenB);
    if (pairAddress != address(0)) {
      (address token0,) = sortTokens(tokenA, tokenB);
      (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairAddress).getReserves();
      (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }
  }

  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
    if (amountIn > 0 && reserveIn > 0 && reserveOut > 0) {
      uint amountInWithFee = amountIn.mul(997);
      uint numerator = amountInWithFee.mul(reserveOut);
      uint denominator = reserveIn.mul(1000).add(amountInWithFee);
      amountOut = numerator / denominator;
    }
  }
}
